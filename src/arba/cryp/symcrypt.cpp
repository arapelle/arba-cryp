#include <arba/cryp/config.hpp>
#include <arba/cryp/symcrypt.hpp>

#include <arba/hash/murmur_hash.hpp>

#include <iostream>
#include <algorithm>
#include <bit>
#include <span>
#if ARBA_CRYP_PARALLEL_EXECUTION_IS_AVAILABLE == 1
#include <execution>
#endif

inline namespace arba
{
namespace cryp
{

symcrypt::symcrypt(const crypto_key& key, std::function<uint8_t()> random_number_generator)
    : key_(key), random_number_generator_(std::move(random_number_generator))
{
}

symcrypt::symcrypt(const uuid::uuid& uuid, std::function<uint8_t()> random_number_generator)
    : key_(uuid.data()), random_number_generator_(std::move(random_number_generator))
{
}

symcrypt::symcrypt(const std::string_view& key, std::function<uint8_t()> random_number_generator)
    : key_(hash::neutral_murmur_hash_array_16(key.data(), key.length())),
      random_number_generator_(std::move(random_number_generator))
{
}

void symcrypt::set_key(const crypto_key &key)
{
    key_ = key;
    start_byte_index_ = hash::neutral_murmur_hash_64(key_);
}

void symcrypt::set_key(const std::string_view& key)
{
    set_key(hash::neutral_murmur_hash_array_16(key));
}

void symcrypt::encrypt(std::vector<uint8_t>& bytes, bool use_parallel_execution)
{
    resize_before_encrypt_(bytes);
    encrypt_bytes_(bytes, parallel_execution_is_available && use_parallel_execution);
}

void symcrypt::decrypt(std::vector<uint8_t>& bytes, bool use_parallel_execution)
{
    decrypt_bytes_(bytes, parallel_execution_is_available && use_parallel_execution);
    resize_after_decrypt_(bytes);
}

// add/remove data size
void symcrypt::resize_before_encrypt_(std::vector<uint8_t>& bytes)
{
    uint8_t bytes_size = min_data_size_1;
    if (bytes.size() <= min_data_size) [[unlikely]]
    {
        // The data are resized so that empty or very small data cannot be guessed.
        bytes_size = static_cast<uint8_t>(bytes.size());
        for (; bytes.size() < min_data_size;)
            bytes.push_back(random_number_generator_());
    }
    // Size information is stored at the end of data.
    bytes.push_back(bytes_size);
}

void symcrypt::resize_after_decrypt_(std::vector<uint8_t>& bytes)
{
    // Size information is retrieved, and data is resized consequently.
    uint8_t bytes_size = bytes.back();
    if (bytes_size <= min_data_size) [[unlikely]]
        bytes.resize(bytes_size);
    else
        bytes.pop_back();
}

// encrypt/decrypt bytes
void symcrypt::encrypt_bytes_(std::vector<uint8_t>& bytes, bool use_parallel_execution)
{
    // Get offsets randomly so that twice encryption of the
    // same data do not generate the same byte sequence.
    offsets offs;
    std::ranges::generate(offs, std::ref(random_number_generator_));
    // Encrypt the byte sequence.
    encrypt_seq_(bytes.begin(), bytes.end(), offs, use_parallel_execution);
    // The offsets must be appended to the generated byte sequence
    // as it cannot be guessed by the decrypter.
    encrypt_and_stores_offsets_(bytes, offs);
}

void symcrypt::decrypt_bytes_(std::vector<uint8_t>& bytes, bool use_parallel_execution)
{
    // Get the offsets, and remove them from the byte sequence to decrypt.
    offsets offs;
    decrypt_and_retrieves_offsets_(bytes, offs);
    // Decrypt the byte sequence.
    decrypt_seq_(bytes.begin(), bytes.end(), offs, use_parallel_execution);
}

// encrypt/decrypt offsets
void symcrypt::encrypt_and_stores_offsets_(std::vector<uint8_t>& bytes, const offsets& offs)
{
    uint64_t key_hash = hash::neutral_murmur_hash_64(key_.data(), min_data_size);
    std::array key_hash_bytes = uint64_to_array8_(key_hash);

    bytes.reserve(bytes.size() + offs.size());
    for (auto key_iter = key_hash_bytes.begin(); const uint8_t& offset : offs)
    {
        bytes.push_back(offset + *key_iter);
        ++key_iter;
    }
}

void symcrypt::decrypt_and_retrieves_offsets_(std::vector<uint8_t>& bytes, offsets& offs)
{
    uint64_t key_hash = hash::neutral_murmur_hash_64(key_.data(), min_data_size);
    std::array key_hash_bytes = uint64_to_array8_(key_hash);
    std::span offsets_span(&*(bytes.end() - offs.size()), offs.size());

    auto key_iter = key_hash_bytes.begin();
    auto span_iter = offsets_span.begin();
    for (uint8_t& offset : offs)
    {
        offset = *span_iter - *key_iter;
        ++span_iter;
        ++key_iter;
    }
    bytes.resize(bytes.size() - offs.size());
}

void symcrypt::encrypt_seq_(std::vector<uint8_t>::iterator begin, std::vector<uint8_t>::iterator end,
                            const offsets& offs, [[maybe_unused]] bool use_parallel_execution)
{
    auto transform_byte = [&](uint8_t& byte)
    {
        auto [offset, shift] = this->crypto_modifiers_(&*begin, &byte, offs);
        uint8_t aux = byte + offset; // Add an offset to the byte,
        byte = std::rotl(aux, shift); // bitwise left-rotate the byte.

//        uint8_t offset = this->crypto_offset_(&*begin, &byte, offs);
//        uint8_t aux = byte + offset;
//        byte = std::rotl(aux, std::popcount(aux) * std::popcount(offset));
    };
#if ARBA_CRYP_PARALLEL_EXECUTION_IS_AVAILABLE == 1
    if (use_parallel_execution) [[likely]]
        std::for_each(std::execution::par, begin, end, transform_byte);
    else
        std::for_each(begin, end, transform_byte);
#else
    std::for_each(begin, end, transform_byte);
#endif
}

void symcrypt::decrypt_seq_(std::vector<uint8_t>::iterator begin, std::vector<uint8_t>::iterator end,
                            const offsets& offs, [[maybe_unused]] bool use_parallel_execution)
{
    auto transform_byte = [&](uint8_t& byte)
    {
        auto [offset, shift] = this->crypto_modifiers_(&*begin, &byte, offs);
        uint8_t aux = std::rotr(byte, shift);
        byte = aux - offset; // bitwise right-rotate the byte and remove the offset.

//        uint8_t offset = this->crypto_offset_(&*begin, &byte, offs);
//        byte = std::rotr(byte, std::popcount(byte) * std::popcount(offset)) - offset;
    };
#if ARBA_CRYP_PARALLEL_EXECUTION_IS_AVAILABLE == 1
    if (use_parallel_execution) [[likely]]
        std::for_each(std::execution::par, begin, end, transform_byte);
    else
        std::for_each(begin, end, transform_byte);
#else
    std::for_each(begin, end, transform_byte);
#endif
}

uint8_t symcrypt::crypto_offset_(uint8_t* first_byte_iter, uint8_t* byte_iter, const offsets& offs)
{
    std::size_t byte_index = byte_iter - first_byte_iter;
    uint8_t key_byte = key_[byte_index % min_data_size];
    std::size_t offset_index = key_.back() + byte_index + (byte_index / (offs.size() + 1));
    uint8_t offset = offs[offset_index % offs.size()]; // random start offset
    offset += static_cast<uint8_t>(byte_index % 256);  // avoid repetition
    offset += key_byte;
    return offset;
}

std::pair<uint8_t, int> symcrypt::crypto_modifiers_(uint8_t* first_byte_iter, uint8_t* byte_iter, const offsets& offs)
{
    std::size_t byte_index = start_byte_index_ + (byte_iter - first_byte_iter);
    std::size_t offset_index = byte_index + (byte_index / 10);
    uint8_t modifier = offs[offset_index % 7] + key_[byte_index % key_.size()];
    std::pair<uint8_t, int> res{ modifier, modifier };
    res.first += static_cast<uint8_t>(byte_index % 257);
    res.second += static_cast<int>(++byte_index % 9);
    return res;
}

// utility
std::array<uint8_t, 8> symcrypt::uint64_to_array8_(uint64_t integer)
{
    std::array<uint8_t, 8> array;
    for (uint8_t& byte : array)
    {
        byte = integer % 256;
        integer /= 256;
    }
    return array;
}

} // namespace cryp
} // namespace arba
